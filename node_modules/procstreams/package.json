{
  "name": "procstreams",
  "version": "0.3.0",
  "description": "Enable easier shell scripting in node",
  "url": "https://github.com/polotek/procstreams",
  "keywords": [
    "pipe",
    "child process",
    "command line",
    "cli",
    "shell scripting"
  ],
  "author": {
    "name": "polotek",
    "url": "Marco Rogers"
  },
  "main": "./procstreams.js",
  "dependencies": {
    "inherits": "~1.0",
    "shell-quote": "*",
    "data-collector-stream": "*",
    "semver": "*"
  },
  "devDependencies": {
    "tap": "*"
  },
  "scripts": {
    "test": "tests/run_tests.sh"
  },
  "readme": "`procstreams` is module to facilitate shell scripting in node.\n\nThis is the first phase. Right now all it does is make it easier\nto create child processes and compose them together in a similar way to\nunix command line scripting.\n\n    var $p = require('procstreams');\n    $p('cat lines.txt').pipe('wc -l')\n      .data(function(stdout, stderr) {\n          console.log(stdout); // prints number of lines in the file lines.txt\n      });\n\n    $p('mkdir foo')\n      .and('cp file.txt foo/')\n      .and('rm file.txt')\n        .on('exit', function() {\n          console.log('done');\n        });\n\n## procstream function\n\nThe procstream function is the main entry point which creates a child\nprocess that's pipeable and composable. It takes arguments in several\nformats. It returns a `ProcStream` object that represents the child process.\n\n    procstream(cmd, argsArray, options, callback)\n\n`cmd` can be the name of the command, or an array of strings with cmd and args\nor a string of cmd + args.\n\n`args` (optional) can be a string of args or an array of arg strings\n\n`options` (optional) options object\n\n`callback` (optional) callback to be called on the \"exit\" event from the proc.\nIt receives the same arguments as the child process exit callback\n\n### options\n\nThe options object supports all of the options from [`child_process.spawn`](http://nodejs.org/docs/v0.6.5/api/child_processes.html#child_process.spawn) plus\na few additions specific to procstreams:\n\n`out` - Boolean that determines if the proc output is directed to the main\nprocess output\n\nIf this options is `true` (strictly), the stdout and stderr of the\nchild process is directed to the stdout and stderr of the calling\nprocess. This is false by default.\n\n\n## ProcStream\n\nThe ProcStream object represents the child process that is being\nexecuted. It is an `EventEmitter` and it also has various methods for\nchaining procstreams together.\n\n\n### procstream methods\n\nEach procstream has a set of methods that aid composition. Each of these\nmethods takes as input a procstream or a set of arguments like the\nprocstream function. Each method returns the input procstream so it can\nbe chained.\n\n**proc1.pipe(proc2)**\n\nSimilar to node's `Stream.pipe`, this is modeled after unix command\npiping. The stdout of `proc1` is directed to the stdin of `proc2`. This\nmethod chains by returning `proc2`.\n\n`proc2` can also be a node `Stream` object and can be interleaved with piping to\ncommands:\n\n    var $p = require('procstreams');\n\n    $p('cat tests/fixtures/10lines.txt')\n      .pipe('grep even')\n      .pipe('wc -l')\n      .pipe(process.stdout)\n\nIf your `Stream` object has a `write()` function and emits `'data'`\nevents then you can interleave shell commands with streaming map\nfunctions:\n\n    var $p = require('../')\n    var Stream = require('stream').Stream\n\n    // build a custom stream to grep even lines from input\n    var grepEven = new Stream\n    grepEven.writable = true\n    grepEven.readable = true\n\n    var data = ''\n    grepEven.write = function (buf) { data += buf }\n    grepEven.end = function () {\n      this.emit('data', data\n        .split('\\n')\n        .map(function (line) { return line + '\\n' })\n        .filter(function (line) { return line.match(/even/) })\n        .join('')\n      )\n      this.emit('end')\n    }\n\n    $p('cat ../tests/fixtures/10lines.txt')\n      .pipe(grepEven)\n      .pipe('wc -l')\n      .pipe(process.stdout)\n\n**proc1.then(proc2)**\n\nLike 2 commands run in succession (separated by ';'), `proc1` is run to\ncompletion; then `proc2` is run. This method chains by returning\n`proc2`.\n\n**proc1.and(proc2)**\n\nLike the `&&` operator, `proc1` is run to completion; if it exits with a\n0 error code, `proc2` is run. If the error code is non-zero, `proc2` is\nnot run. This method chains by returning `proc2`.\n\n**proc1.or(proc2)**\n\nLike the `||` operator, `proc1` is run to completion; if it exits with a\nnon-zero error code, `proc2` is run. If the error code is zero, `proc2`\nis not run. This method chains by returning `proc2`.\n\n**proc.data(fn)**\n\n    $('cat some-large-file.txt')\n      .data(function(err, stdout, stderr) {\n        // process the full output of the proc\n      })\n\nThis function will cause the output of the proc to be collected and\npassed to this callback on exit. The callback receives an error object\nas the first parameter, and the stdout and stderr of the proc. This\nmethod chains by returning the same proc.\n\n**proc.out()**\n\nDirect the stdout and stderr of the proc to the calling process. Use\nthis if you want to forward the output from a child process to the\nmain process. This method chains by returning the same proc.\n\n\n## Why?\n\nShell scripting languages are extremely powerful, but they're also\nannoyingly esoteric. They're difficult to read because of the terse and\nobscure syntax. And for most web programmers they only come up often\nenough to be frustrating. Many people now use general purpose languages\nlike python and ruby because they're more familiar and easily installed\nin most environments.\n\nBut currently node isn't very good for this type of scripting. So\nprocstreams is my attempt to add some nice abstractions to the node api\nthat enable easier scripting in javascript.\n\n\n## TODO\n\n* Better `cd` support. Right now you have to pass the `cwd` option to each proc.\n* Add options for converting the format of proc output, e.g. numbers, json, etc.\n* Add better ways to take action at various events in the proc chain execution\n* Allow execution of a custom function as part of the proc chain\n\n\n## The MIT License\n\nCopyright (c)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "_id": "procstreams@0.3.0",
  "dist": {
    "shasum": "add0c53ee3517473d274427cbe624e8697ec2f3e",
    "tarball": "http://registry.npmjs.org/procstreams/-/procstreams-0.3.0.tgz"
  },
  "maintainers": [
    {
      "name": "polotek",
      "email": "marco.rogers@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "add0c53ee3517473d274427cbe624e8697ec2f3e",
  "_resolved": "https://registry.npmjs.org/procstreams/-/procstreams-0.3.0.tgz",
  "_from": "procstreams@*"
}
